<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Stormの博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="施比受更为有福">
<meta property="og:type" content="website">
<meta property="og:title" content="Stormの博客">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Stormの博客">
<meta property="og:description" content="施比受更为有福">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Stormの博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Stormの博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习做一只会分享的猿</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-关于CAS思想的一些思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/29/%E5%85%B3%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2020-02-29T09:56:55.575Z" itemprop="datePublished">2020-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/29/%E5%85%B3%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">关于CAS思想的一些思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在复习java的一些基础知识，重新对于一些比较模糊的概念进行了一番梳理。用一些实际的案例来加深自己的理解证实是一个行之有效的好办法。<br>关于CAS其实早有耳闻，在刚刚开始接触java的时候遍已经听闻过它的大名，然而所学尚欠火候，始终无法得其真谛，现今虽不能自信地说完全懂得，但好歹有一些自己总结的东西可以聊聊。</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>首先在谈及CAS之前，还是得先聊聊乐观锁这个概念。顾名思义，乐观乐观即总是倾向于把事情往好的方面去想。 锁呢，大家应该都不陌生了。<br>在并发环境中，为了保证数据的安全性而设立的一种保障机制。字大家都认识，但有时候组合起来吧就懵圈了。咳咳，回到正题上来。<br>乐观锁呢，实际属于一种概念，我们可以理解为接口定义，定义它是干什么用的，而CAS呢其实是它的一种实现。可以试着这么去理解，<br>即在对目标数据进行修改前，我总是倾向于相信这个数据当前没有人修改，只有我自己。那我就直接读取数据，然后修改成我想要的值，但是为了确保万无一失（想着没人改不代表就没人改）<br>在准备提交的时候呢再校验一下是不是有人修改了。因为我只是倾向于相信没有人修改，但是实际有没有呢这个是只有验证才知道的。<br>（我们暂时先不去管怎么个验证法）因为它还不是具体实现机制。如果没人修改就直接提交，<br>如果有人修改就说明自己的倾向判断错了，需要重新读取最新数据，回到这个验证的过程，一直重复这个过程直到确定没人修改再提交。</p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS(Compare And Set)是乐观锁的一种具体实现机制，从名字上就能看出来是基于比较的一种机制。上文的介绍中我没有详细进行说明的验证方法，在CAS中其实是这么执行的。读取目标数据后，缓存起来。<br>然后带着想要设置的值进入准备提交的阶段，这时再读取一次目标数据，比较缓存值和当前目标值是否一致（目标值必须是内存可见的，在java中使用volatile修饰）。如果数据一致则代表当前没有其他人（线程）操作目标。<br>这时就可以放心提交啦，但是如果不相等就需要再次回到读取验证和预提交的环节。这个环节可以称之为“自旋”。（因为如果线程竞争比较激烈的时候，它就一直在循环读取比较啦，宏观表象就是转圈）。</p>
<h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>关于上述基本的CAS原理，大家应该都看明白了，因为还是比较简单的。但是这个机制真的没问题吗，其实暴露了一个称之为“ABA”的问题。细心的小伙伴想必应该已经发现了，<br>就是我们验证缓存值和当前目标值相不相等，以此来作为是否有线程修改的依据其实是有问题的。如果我们缓存值为0，我们的线程想把它更改为1，这个时候我们还没有读取值，但是有另一个线程把它改为了1随后马上又改成了0，<br>这时我们的线程读取目标值也为0。虽然结果一样，但是中间过程却隐藏了，程序无法感知，这就是“ABA”问题。</p>
<h2 id="解决ABA"><a href="#解决ABA" class="headerlink" title="解决ABA"></a>解决ABA</h2><p>那如何解决ABA问题呢，我们引入一个版本号的概念，目标值初始化时给定一个版本，例如1.0，在修改目标值的时候我们就加一个版本。以后每次判断目标值与缓存值相不相等的时候必须校验值和版本是否一致，<br>其中有一个不一致的时候必须重新从内存读写最新的值。这样就不存在“ABA”问题了。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>以上关于乐观锁和CAS的介绍就差不多了，相对乐观锁其实就有悲观锁的说法。概念上也是很好理解的，在操作目标数据时，总是倾向于认为有人也在修改数据，为了保证数据安全，我必须先锁住当前目标才敢操作（排他性）。<br>在java当中synchronized就是悲观锁的一种实现，是不是很好理解呢，被它修饰的方法都是同步执行的。</p>
<h2 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h2><p>从实现上来讲，其实很直观的能看出乐观锁比悲观锁的效率要更高。因为悲观锁是宁可错杀一千，不可放过一个，一律同步执行。就synchronized这种JVM层级的锁来说早期实现是比较重的，执行效率很慢，<br>但是经过这么多年的版本迭代更新，它的效率已经不可同日而语了。但是具体的效率还是得看线程并发环境，如果竞争非常激烈，乐观锁因为长时间的自旋其实会拖慢效率甚至比使用悲观锁还要慢。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>jdk1.8当中ConcurrentHashMap是直接使用的 CAS + Synchronized来保证线程安全的。（1.7当中使用的是分段可重入锁ReentrantLock）相反的HashTable和Collections.synchronizedMap()则直接使用的是synchronized这种悲观锁来保证线程安全，<br>在一般情况下前者的效率还是大大比后者好的。</li>
<li>CAS在自旋锁当中也有运用，只是把资源换成了锁，有兴趣的小伙伴可以自行查阅，是很好理解的</li>
<li>java轻量级锁属于乐观锁，重量级锁的实现属于悲观锁</li>
<li>基于自旋锁可以动态根据竞争压力调整锁的策略，从偏向锁转化为轻量级或者重量级锁（锁状态：无锁状态、偏向锁、轻量级锁和重量级锁，单向升级从低到高）JDK 1.6中默认是开启偏向锁和轻量级锁的。</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>掌握CAS的思想，对于创建复杂多变的多线程应用是很有帮助的，借此可以实现轻量级的线程安全机制，对于理解很多复杂的程序设计思想（流行的redis事务等等）也有很好的果效。这期的分享完啦，前路慢慢，以此为记。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/29/%E5%85%B3%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" data-id="ck77icubo0004939k2y3u5ol0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于单元测试的一点思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/17/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2020-01-17T14:05:25.791Z" itemprop="datePublished">2020-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/17/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于单元测试的一点思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hello,我是Storm。今天呢很想就单元测试这个点整理一下。在平时的coding当中，其实单元测试应该是用的比较多的，但是不知道大家有没有跟我有一样的感受。在测试自己的工具类或者比较简单的模块时，用junit等这样的测试框架就很方便的解决了问题。但是一旦测试的代码依赖于太多第三方的模块，或者自己写的其他模块代码，测试就变得非常麻烦，因为你需要启动这些三方服务或者模块。特别是分布式环境下，自己开发机器又不是性能优越的情况下那简直就是噩梦。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>那有没有方便的测试思想或者方法甚至工具可以帮我们摆脱这种困扰呢，答案是肯定的。但是还是想自己来想一想，这个背后到底是怎么个原理。针对我们遇到的问题，无非就是“解耦”，如何在不影响现有测试流程的情况下，把测试需要的环境给准备好。</p>
<p>例如需要某个接口服务，这个接口服务我们不关心它是分布式的还是单例的，网络状况如何，我只关注它给我返回的数据。在java中我们就可以借助依赖注入的方式来解决，自己实现一个接口，或者直接new一个服务，覆盖其方法，返回值直接设置成我们需要的数据，以此来模拟实例化一个服务。甚至我们可以自定义一个流程，在调用某些方法的前后来定制这个入参和返回值，以此达到测试的目的。</p>
<p>同时我也发现一个问题，对于服务、接口我们可以依赖注入的方式来规避，但是静态方法呢就不太好处理了。简单的方法还好，对于复杂的静态方法引入了过多外部资源其实很影响代码的可测试性，因此提醒自己在写码的时候要注意规避这种问题，也算是测试驱动开发（TDD）的一种应用吧。</p>
<h1 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h1><p>mock即模拟，在测试领域指的是模拟与测试相关的数据和环境，达到解耦第三方依赖的目的而只关注测试目标本体的思想方法。在java生态中比较常用的mock工具有EasyMock（早起流行）、Mockito（改进了EasyMock,主流）、PowerMock(主流)、Jmockit（轻量）等等。这里我简单介绍一下Mockito的用法。</p>
<p>Mockito可以让你轻松模拟任何Java类行为和数据，并且可以跟踪执行流程，自定义测试节点的参数和方法返回值，从而解耦第三方依赖，简化单元测试。<br><img src="http://118.89.17.131:8090/upload/2020/1/PUZZLE-1-min%20(1)-deeefee3ac0743b0bc64b34c2292260a.png" alt="PUZZLE1min 1.png"></p>
<h1 id="Mockito基本使用"><a href="#Mockito基本使用" class="headerlink" title="Mockito基本使用"></a>Mockito基本使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMockObject</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 使用 mock 静态方法创建 Mock 对象.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">       List mockedList = mock(List<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       Assert.assertTrue(mockedList <span class="keyword">instanceof</span> List);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// mock 方法不仅可以 Mock 接口类, 还可以 Mock 具体的类型.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">       ArrayList mockedArrayList = mock(ArrayList<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">       Assert.assertTrue(mockedArrayList <span class="keyword">instanceof</span> List);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">       Assert.assertTrue(mockedArrayList <span class="keyword">instanceof</span> ArrayList);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configMockObject</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//定制类行为</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">       List mockedList = mock(List<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 我们定制了当调用 mockedList.add("one") 时, 返回 true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">       when(mockedList.add(<span class="string">"one"</span>)).thenReturn(<span class="keyword">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 当调用 mockedList.size() 时, 返回 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">       when(mockedList.size()).thenReturn(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">       Assert.assertTrue(mockedList.add(<span class="string">"one"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 因为我们没有定制 add("two"), 因此返回默认值, 即 false.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">       Assert.assertFalse(mockedList.add(<span class="string">"two"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(mockedList.size(), <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">       Iterator i = mock(Iterator<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">       when(i.next()).thenReturn(<span class="string">"Hello,"</span>).thenReturn(<span class="string">"Mockito!"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">       String result = i.next() + <span class="string">" "</span> + i.next();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">//assert</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(<span class="string">"Hello, Mockito!"</span>, result);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span>(expected = NoSuchElementException<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="class">   <span class="title">public</span> <span class="title">void</span> <span class="title">testForIOException</span>() <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟异常</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">       Iterator i = mock(Iterator<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">       when(i.next()).thenReturn(<span class="string">"Hello,"</span>).thenReturn(<span class="string">"Mockito!"</span>); <span class="comment">// 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">       String result = i.next() + <span class="string">" "</span> + i.next(); <span class="comment">// 2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(<span class="string">"Hello, Mockito!"</span>, result);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">       doThrow(<span class="keyword">new</span> NoSuchElementException()).when(i).next(); <span class="comment">// 3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">       i.next(); <span class="comment">// 4</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVerify</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证方法调用情况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">       List mockedList = mock(List<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">       mockedList.add(<span class="string">"one"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">       mockedList.add(<span class="string">"two"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">       mockedList.add(<span class="string">"three times"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">       mockedList.add(<span class="string">"three times"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">       mockedList.add(<span class="string">"three times"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">       when(mockedList.size()).thenReturn(<span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(mockedList.size(), <span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">       verify(mockedList, atLeastOnce()).add(<span class="string">"one"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">       verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"two"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">       verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">       verify(mockedList, never()).isEmpty();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpy</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">//Mockito 提供的 spy 方法可以包装一个真实的 Java 对象, 并返回一个包装后的新对象. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//若没有特别配置的话, 对这个新对象的所有方法调用, 都会委派给实际的 Java 对象.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">       List list = <span class="keyword">new</span> LinkedList();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">       List spy = spy(list);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 对 spy.size() 进行定制.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">       when(spy.size()).thenReturn(<span class="number">100</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">       spy.add(<span class="string">"one"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">       spy.add(<span class="string">"two"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 因为我们没有对 get(0), get(1) 方法进行定制,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 因此这些调用其实是调用的真实对象的方法.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(spy.get(<span class="number">0</span>), <span class="string">"one"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(spy.get(<span class="number">1</span>), <span class="string">"two"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(spy.size(), <span class="number">100</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCaptureArgument</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数模拟</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">       List&lt;String&gt; list = Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">       List mockedList = mock(List<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">       ArgumentCaptor&lt;List&gt; argument = ArgumentCaptor.forClass(List<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">       mockedList.addAll(list);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">       verify(mockedList).addAll(argument.capture());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(<span class="number">2</span>, argument.getValue().size());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">       Assert.assertEquals(list, argument.getValue());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>利用现代化的测试工具和框架能够大大简化日常开发当中涉及到的一些测试工作量，但是也要保持一颗求真的心，知道其背后的思想，才能沉淀成自己的东西。也会加深自己对于框架和工具的理解，更好的使用它。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/17/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" data-id="ck77icubp0005939keepxh2l1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql慢查询分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/15/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2020-01-15T12:37:52.425Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/15/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/">mysql慢查询分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近线上一个报表的查询接口出现慢查询的情况，是比较重要的一个报表。虽然查询sql有些复杂但是针对现有的查询条件和数据库结构做了相关优化，之前查询一年数据在分钟内，现在查一个月数据就需要3分钟，按道理是不应该出现这个问题的。<br>但是本着透过现象看本质的心，还是放下手中刚摸到的鱼开始bug时间。</p>
<h2 id="基础分析"><a href="#基础分析" class="headerlink" title="基础分析"></a>基础分析</h2><p>首先还是本能的定位到目标sql位置，show history了解到这个sql已经半年没有更新了。接着就explain分析，sql该走索引的地方都走了索引。<br>运维那边反馈最近除了把一个分区的数据从固态迁移到机械盘之外，其他的数据并没有动，mysql内存也是足够的。但是为了排除这个因素的影响，还是测试了一下目标分区和其他分区数据的查询速度差别，结果并没有差很多。<br>没办法，只能去追踪详细的sql执行计划了。</p>
<h2 id="正经分析"><a href="#正经分析" class="headerlink" title="正经分析"></a>正经分析</h2><p>首先在从库上执行目标sql，免得加重主库的负担。（这个查询本就是做了读写分离的，查询走的是从库，手动滑稽）<br>但是结果诡异了，竟然只花了10s左右。说好的3分钟呢，感紧催运维查了一下，果然结果是出乎意料的。之前调整，竟然把从库域名配置干掉了，所有查询都打到主库上。赶紧让运维切换到从库去，虽然大石头放下了，但是查询还是没有之前的效果，于是继续跟踪。</p>
<ul>
<li><p>查看正在执行的 SQL 语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询当前执行sql的id 执行用户 数据库 操作类型 耗时 状态 等等</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.<span class="string">`PROCESSLIST`</span> <span class="keyword">where</span> info <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span></span></pre></td></tr></table></figure>
</li>
<li><p>查看 SQL 查询耗时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 profiling 功能是否已打开</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@profiling</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开 profiling</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> profiling=<span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看 profiling</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看某个 query 的耗时情况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> query_id</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看锁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'%lock%'</span>;</span></pre></td></tr></table></figure>

</li>
</ul>
<p>markdown放图片还是不方便呀。从结果上显示，耗时主要发生在 Creating sort index 严重的时候耗费将近90%的时间，mysql的耗时情况分析涉及到很多的子项（mysql状态）具体可以看文末详情。<br>借助万能的Google了解到，这主要是order by 和limit引发的。当涉及到排序和分页的数据过多时性能会急剧下降。因为limit10000,20的意思扫描满足条件的10020行，扔掉前面的10000行，返回最后的20行，问题就在这里。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对于默认查询，不再使用order by。对于一定要使用的排序字段 建立复合索引 排序字段，主键<br>对于分页解决方案是获取到一批数据之后拿到最大的ID，加入到where条件中加入&gt;该ID条件过滤掉前面的数据，在使用子查询获取数据即可。</p>
<h2 id="附录-sql执行状态"><a href="#附录-sql执行状态" class="headerlink" title="附录 sql执行状态"></a>附录 sql执行状态</h2><p>Checking table    正在检查数据表（这是自动的）。<br>Closing tables    正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。<br>Connect Out    复制从服务器正在连接主服务器。<br>Copying to tmp table on disk    由于临时结果集大于tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。<br>Creating tmp table    正在创建临时表以存放部分查询结果。<br>deleting from main table    服务器正在执行多表删除中的第一部分，刚删除第一个表。<br>deleting from reference tables    服务器正在执行多表删除中的第二部分，正在删除其他表的记录。<br>Flushing tables    正在执行FLUSH TABLES，等待其他线程关闭数据表。<br>Killed    发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。<br>Locked    被其他查询锁住了。<br>Sending data    正在处理SELECT查询的记录，同时正在把结果发送给客户端。<br>Sorting for group    正在为GROUP BY做排序。<br>Sorting for order    正在为ORDER BY做排序。<br>Opening tables    这个过程应该会很快，除非受到其他因素的干扰。例如，在执ALTER TABLE或LOCK TABLE语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。<br>Removing duplicates    正在执行一个SELECT DISTINCT方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。<br>Reopen table    获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。<br>Repair by sorting    修复指令正在排序以创建索引。<br>Repair with keycache    修复指令正在利用索引缓存一个一个地创建新索引。它会比Repair by sorting慢些。<br>Searching rows for update    正在讲符合条件的记录找出来以备更新。它必须在UPDATE要修改相关的记录之前就完成了。<br>Sleeping    正在等待客户端发送新请求.<br>System lock    正在等待取得一个外部的系统锁。如果当前没有运行多个mysqld服务器同时请求同一个表，那么可以通过增加–skip-external-locking参数来禁止外部系统锁。<br>Upgrading lock    INSERT DELAYED正在尝试取得一个锁表以插入新记录。<br>Updating    正在搜索匹配的记录，并且修改它们。<br>User Lock    正在等待GET_LOCK()。<br>Waiting for tables    该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, ALTER TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE 或 OPTIMIZE TABLE<br>waiting for handler insert    INSERT DELAYED已经处理完了所有待处理的插入操作，正在等待新的请求。<br>after create    线程创建一个表或临时表的最后会进入该状态<br>Analyzing    线程正在分析一个 MyISAM 表或索引描述（例如 ANALYZE TABLE）<br>checking permissions    线程在查看是否具有权限<br>Checking table    表检查操作<br>cleaning up    线程已处理了一个命令，正在准备释放内存和资源<br>closing tables    线程将更改的表数据刷新到磁盘并关闭使用的表<br>converting HEAP to MyISAM    线程正在将内存表中的内部临时表转换为磁盘上的 MyISAM 表<br>copy to tmp table    线程正在执行一条 alter table 语句，已创建新结构的表，正在将数据复制到新结构的表中<br>Copying to group table    一条语句的ORDER BY和GROUP BY条件不同时，将数据行按组排序并复制到临时表中<br>Copying to tmp table    复制数据到内存中的一张临时表中<br>Copying to tmp table on disk    由于临时结果集大于 tmp_table_size，所以线程正在将临时表从内存中更改为基于磁盘的格式保存<br>Creating index    线程正在对一个 MyISAM 表执行 ALTER TABLE … ENABLE KEYS<br>Creating sort index    正在执行一个使用内部临时表的查询<br>creating table    正在创建一个表（包括临时表）<br>Creating tmp table    线程正在内存或磁盘上创建一个临时表。如果表是在内存中创建的，但稍后被转换为磁盘上的表，则该操作期间的状态将复制到磁盘上的tmp表</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/15/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/" data-id="ck77icube0000939k79k27vnt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-记一次线上内存溢出" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/" class="article-date">
  <time datetime="2020-01-07T12:25:28.290Z" itemprop="datePublished">2020-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/">记一次线上内存溢出</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天上班刚坐到位置上，准备开始摸鱼。呸，开始工作。产品就在钉钉上怼过来一张截图，图上显示dmp系统的几个在跑任务挂了，最后运行时间是昨天下午，状态还是运行中。</p>
<p>于是我放下手中还没啃完的烧麦，开始bug时间。从表象上来看，看不出是什么问题，因为这个业务流程相对来说比较长，每一个环节都有可能出现异常，也许是因为没有考虑到的异常未被捕获造成的。心里这样想着，cd到这个业务昨天的日志文件，是他是他就是他，我们的老朋友。看到这东西，莫名开始激动了起来呢，毕竟是线上为数不多可以看到的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.OutOfMemoryError: GC overhead limit exceeded</span></pre></td></tr></table></figure>
<p>在此之前呢还有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nested exception is com.mongodb.MongoException$CursorNotFound: Cursor 2114193476805984430 not found on server</span></pre></td></tr></table></figure>

<p>于是自然的开始Google一把这个错误，说是驱动版本的问题或者响应超时。快速排出了第一种情况，那么MongoDB怎么就超时了呢。细想一下，最近开发的功能。有一处读取Hive清洗的dmp原始数据到MongoDB，这个部分是写过程但是并没有出现Hive相关的报错信息。因此最大的可能就是落在读取MongoDB这部分数据打包成压缩文件的这个点了。</p>
<p>果然排查之后发现，在昨天的下午这个时间点。有业务人员操作了一个400W数据的包体，并且使用了其管理的5个账号。当时为了能够在同一时间处理多个任务，以及考虑到第一期清洗数据单个包体不会超过300W的情况下，开启线程池同时执行的最大线程数设置成了8。</p>
<p>因此在这种情况下，几乎同一时段加载到内存当中的数据为5x400W=2000W 而该Java进程设置的最大内存为4G，所以超出了内存上限导致溢出。</p>
<p>问题定位到了，就好解决了。与产品和运维沟通。该业务并不要求实时性，因此把并发线程数降到3，同时扩展内存到6G。对于大数据量的包体，进行切分，分批次查询数据append进文件中再打包。同时观察线上运行情况，及时调整，做好失败重试方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/" data-id="ck77icubt0008939k0ohj3ein" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于异常处理的一点思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-12-24T06:13:13.657Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于异常处理的一点思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于异常处理，在网上的大部分博客大多关注编程语言本身的异常处理机制。而很少谈及在业务当中的实际应用情况。因而不是很能够get到其中的要点。这部分感觉只能自己多多思考和积累了。</p>
<p>最近在工作当中开发的一些基于Quartz任务调度实现的自动化功能，涉及到比较长的运行流程。包括hive数据的清洗导出，数据分包，打包成txt或者zip，多文件上传，自动重试。而每一个流程当中可能会出现诸多的异常，对应于多个运行的结果状态。</p>
<p>如何保证不管结果如何，到每一个流程运行完都能标记为正确的状态，并且可以通过结果来进行自动重试，最后能够将结果信息、错误信息返回到顶层？如何编码能够避免过多的if条件判断，拥有统一的编码风格？</p>
<p>查看了类似业务的编码，因为多状态的问题，代码判断很多导致可读性很差。对于多个渠道对应不同的上传预处理方式，直接判断处理导致代码更加臃肿。为此，我决定重构一下这块逻辑，以便更好的扩展和维护。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，将所有可能出现的正常和异常情况列出来，然后归类，设计对应的枚举值。然后定义一个统一的处理结果类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//处理结果标记</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//结果代码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> String resultCode;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//存储的结果对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> Object model;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//返回信息，用于上层展示</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> String message;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//调用链存储结果对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//调用链存储错误信息</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">private</span> Map&lt;String, String&gt; errorMessages = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>接下来，我们所有的业务处理正常返回的数据都存储到这个结果对象当中。或者定义一个统一的业务异常类来集中处理。对于具体的异常处理，我们用try catch捕获，对于底层的就通过结果对象往上层调用传。在上层业务通过取结果对象当中的代码或者错误消息还有返回数据对象等等来统一处理当前业务的状态变更，而不在下层处理导致底层模块以来上层业务。</p>
<p>对于底层异常来说，因为比较独立。例如文件的打包等等，我们就没必要做统一异常的处理。这个时候用throws 往上层抛出，上层接受后在统一处理。另外对于并发锁的部分我们要在finally当中单独进行处理。</p>
<p>关于不同渠道的文件上传，因为有不同的数据预处理方式，走的接口也是完全不一样的，没有办法统一，但是它们在抽象上都属于上传这个领域。因此，我考虑使用工厂模式来组织代码。在服务层，依赖于工厂和上传接口。而工厂去生产具体的上传服务，各渠道服务实现抽象上传接口。从而实现这部分引起的业务逻辑判断过多的问题。</p>
<h2 id="踩坑总结"><a href="#踩坑总结" class="headerlink" title="踩坑总结"></a>踩坑总结</h2><p>具体的实现过程当中，还是发现因为判断多而思路不清晰的时候。不过当我把业务拆解到更细粒度的方法的时候就变的清晰很多了。很重要的经验：<strong>先处理异常情况，最后在处理正常情况</strong><br>虽然是日常编码中很小的点，但是正是这些小地方让代码变得更优雅。争哥的设计模式课程的学习，给到我很大的看见，继续加油Storm。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" data-id="ck77icubq0006939kdk0qdg98" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-记一次线上Redis资源优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/" class="article-date">
  <time datetime="2019-12-20T08:37:31.937Z" itemprop="datePublished">2019-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/">记一次线上Redis资源优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>最近在开发一个数据仓库的小版本，因为自己的疏忽（误以为一个重要的流程可以复用，实际不可以）导致工期估计很少而坑了自己，一周的时间都在加班搞这个事情。幸好还是扛下来，少不了同事老毕的帮助，还是很感激有这样的同事的。版本进入测试阶段，终于有时间可以来开始写写博客。这个等版本上线之后可以在来复盘一下。</p>
<p>今天呢，主要是想仔细来梳理一下之前做的一个版本优化，主要是针对线上的一块大流量业务做的Redis资源优化，优化之后这块业务内存资源节约超过65%。在不影响性能的情况下，缓存时间从1天提高到7天。话不多说，下次开始吧。</p>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>公司有广告数据上报的业务，峰值在1200w+每天，均值600w+。为了应对复杂的归因流程，以及归因回调，需要将这部分数据放入缓存，以免给数据库造成太大的压力。回调相关的参数数据也是放在缓存当中的，缓存保留时间是1天。</p>
<h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p>为了提高归因率，现需要把缓存时间从1天提升到7天。这意味着缓存数据量是原来的7倍，并且增加两种匹配机制，数据量又增加30%。<br>（我们线上的Redis内存最大容量是16G，12G为告警阈值，按照现有的机制增加的话理论计算上面就已经超过阈值了，因此肯定是要优化的）</p>
<h2 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h2><p>为了清楚现有业务内存的占用情况，分别对涉及到的7种匹配机制进行调研。在本地分别测试10W数据的内存大小。间隔5天取近两个月的数据总量进行统计，取均值和峰值以及8倍峰值数据量，分别计算理论情况下，各个匹配机制所需要的Redis内存大小。</p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>业务层面来说，用户点击广告不一定会下载激活游戏来玩，这一层级的转化其实是有很大损失的，因此匹配回调的数据可以和点击数据剥离。考虑到不同渠道的数据格式和参数个数，检测数据类型不一样的原因，为了便于往后扩展，这里考虑使用MongoDB来存储这部分的数据。</p>
<p>为了不降低归因的效率，我们提供一个主键来允许其他系统业务定位到具体的点击数据。自然的Redis中我们就直接缓存这个主键，而不在缓存原始数据了。归因匹配上了，我们在直接通过原始数据来构造回调参数。这样即使增加了匹配机制类型，但是总的数据量还是减少了很大一部分。<br>（对于日均量来说，减少了78.3%，对于峰值来说减少了58.7%）</p>
<p>至此还有，最后一个问题没有解决。如何处理7天缓存的这个问题呢。从业务上面分析，对于超过一天的这部分数据，是指一个用户点击了广告，但是呢在一天之后才激活，当然这其中也存在异常激活的情况，但是比较少。</p>
<p>为了这个少部分的数据， 而且不是热点的数据，来缓存如此庞大的数据是非常不优雅的。为此，我们使用到MongoDB的另外一个特性来解决这个问题。</p>
<p>对于MongoDB来说，可以设置文档的自动过期时间，虽然它的精确度不是特别高，但是对于7天来说可以忽略。你是不是已经知道我要干什么了。对的，我们把超过一天缓存的数据都写到MongoDB当中，设置过期时间为7天，我们也只存储它的索引，用于定位，这个缓存库设置分片。</p>
<p>这样整个优化，在理论上就可行了，接下来就是动手实践的时候。具体实施的过程还是踩了一些坑，但都是可以实战解决的。</p>
<h2 id="复盘总结"><a href="#复盘总结" class="headerlink" title="复盘总结"></a>复盘总结</h2><p>对于这次优化而言，其实没有特别大的技术点，要点还是在于业务的剖析，能够准确定位哪些是热点数据，哪些是半热数据，哪些是冷数据。从而针对不同类型的数据做文章，分割开来用不同的手段处理。当然对于业务规模的前期调研以及后期扩展的展望也是非常重要的，能够让我们清晰的知道现有系统的健康状况，能不能支撑我们做迭代，以及相对长期的迭代。</p>
<p>我相信这还只是一个开始，未来的路还很长。Storm，砥砺前行！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/" data-id="ck77icubs0007939k9vnr3k6z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用docker部署高可用的Eureka集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84Eureka%E9%9B%86%E7%BE%A4/" class="article-date">
  <time datetime="2019-12-06T09:59:50.796Z" itemprop="datePublished">2019-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84Eureka%E9%9B%86%E7%BE%A4/">使用docker部署高可用的Eureka集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>Hi，小伙伴们。继上期分享了如何用Docker部署自己的第一个SpringBoot应用之后，爱折腾的Storm还是耐不住性子，又折腾了一下SpringCloud应用的部署。在不使用Docker部署的时候呢，在本地模拟搭建一个高可用的Eureka集群是相当简单的。但是使用Docker部署的时候遇到了节点无法通信的问题，折腾半天终于完美解决这个问题，以此记录一下。</p>
<h3 id="原因猜测"><a href="#原因猜测" class="headerlink" title="原因猜测"></a>原因猜测</h3><p>在项目中，我使用的是域名来区分不同的Eureka服务，本地Host绑定这些域名解析为127.0.0.1 但是部署到容易当中的时候就无法进行通信了，因此需要使用其他方法来建立通信。更改配置，使用ip并不是我的意图，虽然在实际生产环境是可以的，但是硬编码的风格显然不是最好的方案。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>经过资料的收集和整理，发现docker-compose能够解决这个问题，它能够自定义编排要发布的容易，包括容器依赖和通信并且统一部署。因此我在此使用它来解决上述的部署问题。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先我们需要构建Eureka服务，使用不同的端口，具体源码见我的开源项目</p>
<ul>
<li><a href="https://github.com/Aspire814/SpringBoot-Cloud-Learning.git" target="_blank" rel="noopener">SpringBoot-Cloud-Learning</a>:<br>分别绑定配置文件中的三个域名到host，解析到127.0.0.1<br>尝试直接启动这单个SpringBoot应用，是可以直接发布成分布式高可用Eureka集群的。<br>进入<a href="http://eureka-server-01:1001/eureka/可以看到相应的监控界面" target="_blank" rel="noopener">http://eureka-server-01:1001/eureka/可以看到相应的监控界面</a><br>接下来我们用Docker单独构建这三个应用，具体方法可以看我上一期的文章。</li>
<li><a href="https://aspire814.github.io/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">使用Docker部署SpringBoot应用</a>:</li>
</ul>
<h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><p>我们需要在项目根目录下新建一个docker文件夹，用于存储Docker部署相关的文件，在此文件夹下新建一个docker-compose.yml文件，内容如下</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2.1"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">eureka-server-01:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">image:</span> <span class="string">eureka-server-01</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-server-01</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">networks:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="string">eureka-net</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">ports:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="string">"1001:1001"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">eureka-server-02:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">image:</span> <span class="string">eureka-server-02</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-server-02</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">networks:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="string">eureka-net</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">ports:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="string">"1002:1002"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="attr">eureka-server-03:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">image:</span> <span class="string">eureka-server-03</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka-server-03</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">networks:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="string">eureka-net</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="attr">ports:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      <span class="bullet">-</span> <span class="string">"1003:1003"</span></span></pre></td></tr></table></figure>
<p>这里的配置主要是编排我们将要发布的三个容器基本信息，包括容器的名称，镜像名称，host名称，端口等等。这样我们统一发布这些应用，应用之间就可以相互通信了，而不是网络隔离的状态。</p>
<p>最后我们在idea中运行这个文件，不出意外的话，我们就可以看到三个容器正常部署并且输出打印日志。同样的，访问<a href="http://eureka-server-01:1001/eureka/" target="_blank" rel="noopener">http://eureka-server-01:1001/eureka/</a> 查看是否有挂载3个节点，并且都处于正常状态。到这里高可用Eureka高可用服务注册与发现中心得Docker部署搭建就完成啦，这个也是同样可以用于Feign等Eureka客户端的部署使用过程当中的，大家可以自行尝试。我的项目当中已经为大家准备好了Demo，可以自行查看。我们下期见吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84Eureka%E9%9B%86%E7%BE%A4/" data-id="ck77icubl0002939kadaab7w9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用docker部署我的第一个SpringBoot应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/" class="article-date">
  <time datetime="2019-12-06T08:36:41.671Z" itemprop="datePublished">2019-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/">使用docker部署我的第一个SpringBoot应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hi，我们又见面啦。最近Storm在研究docker部署相关的知识点，也是踩了不少坑，于是就有了下面的这篇文章，给准备捣鼓这一块的小伙伴一点前车之鉴，话不过说我们开始动手吧。</p>
<p>ps：还是忍不住安利一波，因为Storm之前一直使用的主力生产工具是Eclipse，公司里面也是统一使用的这个工具，为此老大还自己研发了一些插件，这款IDE还是相当强大的。</p>
<p>但是从两个月前上手idea开始就一发不可收拾，再也回不去了，墙裂安利大家去折腾一下，你也会爱不释手的。不用担心说团队的原因或者快捷键等等，因为这些都已经有人踩过坑啦。解决方案都是现成的，工欲善其事必先利其器，所以蠢蠢欲动不如行动吧，哈哈哈。</p>
<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>在这篇文章当中我不过多介绍SpringBoot项目的构建过程，因为随便搜一下就有一堆。简单的几项配置，就能跑起来，重要的还是需要检查一下你的环境。包括IDE，Maven，Java等等</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p><a href="https://www.docker.com/" target="_blank" rel="noopener">下载传送门：docker官网</a><br>根据你的开发环境，选择安装相应的版本（实测基本使用mac和win是类似的）<br>安装就是傻瓜式的软件安装，<strong>注意</strong>设置你的docker镜像存放位置，因为它默认是放在<strong>C:盘</strong>的</p>
<h2 id="设置docker"><a href="#设置docker" class="headerlink" title="设置docker"></a>设置docker</h2><p>启动docker后，在任务栏处会看到一个docker的小鲸鱼图标，右键打开Settings切换到General选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">勾选 Expose daemon on tcp://localhost:2375 without TLS</span></pre></td></tr></table></figure>
<p>将docker连接的端口暴露到开发环境当中，便于我们连接docker操作我们的镜像和容器</p>
<h2 id="idea配置docker环境"><a href="#idea配置docker环境" class="headerlink" title="idea配置docker环境"></a>idea配置docker环境</h2><p>接下来我们需要在idea中安装一个docker的插件<strong>Docker integration</strong><br>打开idea，从File-&gt;Settings-&gt;Plugins-&gt;Install JetBrains plugin进入插件安装界面，在搜索框中输入docker，可以看到Docker integration，点击右边的Install按钮进行安装。</p>
<p>安装后重启idea，从File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker打开配置界面<br>新建一个docker连接，名字随意，将上面我们勾选的地址复制到TCP socket选项中 看到下方窗体中出现Connection Successful就说明配置成功啦</p>
<h2 id="部署项目到docker"><a href="#部署项目到docker" class="headerlink" title="部署项目到docker"></a>部署项目到docker</h2><h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><p>首先我们要先将我们构建好的SpringBoot项目打包，这里使用到maven的构建工具。<br>在SpringBoot项目的pom文件中加入如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">			<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">				<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">					<span class="tag">&lt;<span class="name">id</span>&gt;</span>SpringBootApp<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">					<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">					<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">						<span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">							<span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"docker"</span> <span class="attr">file</span>=<span class="string">"target/$&#123;project.artifactId&#125;-								$&#123;project.version&#125;.$&#123;project.packaging&#125;"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">						<span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">					<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">					<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">						<span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">					<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">				<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">			<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span></pre></td></tr></table></figure>
<h3 id="构建镜像-部署docker"><a href="#构建镜像-部署docker" class="headerlink" title="构建镜像 部署docker"></a>构建镜像 部署docker</h3><p>到这一步，我们就要开始进入关键点啦，前面都是准备工作。<br>首先，在项目的根目录（注意是根，不是src或者mian）新建一个docker文件夹用于存放docker相关的文件<br>新建一个Dockerfile文件 （这个是镜像构建文件，即告诉docker需要为我们的项目准备什么环境）<br>具体内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">FROM java:8u111</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">VOLUME /tmp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ADD *.jar app.jar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">EXPOSE 8088</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 时区</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">RUN cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></pre></td></tr></table></figure>
<p>如上配置，说明我们的项目运行在java8环境当中，使用的是Ubuntu系统的环境，将8088端口映射到docker环境之外，我们就可以在宿主机（开发机器）访问到这个端口，其他配置具体细节可以自行Google</p>
<p>配置好Dockerfile之后，我们右键它create docker/Dockerfile 在docker配置对话框中输入容器的名称<br>添加端口映射8088:8088<br>添加在构建之前运行的maven命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">clean package -Dmaven.test.skip = <span class="literal">true</span></span></pre></td></tr></table></figure>
<p>构建项目时，会自动将target下打好的jar复制到项目根目录，我们发布到docker时会使用这个jar。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>一切准备就绪，接下来我们右键运行Dockerfile文件，在docker文件夹下就会出现打好的项目jar包，docker就开始构建镜像，配置容器，然后发布jar包到容器的tmp目录下，最后启动项目，你就可以在插件的控制台看到Spring的Banner以及相关启动日志啦。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是这一期docker部署我的第一个SpringBoot项目的全部内容啦，大家多动手试试吧。可能会有细节没有把握到，请多多包涵，我们下期见吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/06/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8/" data-id="ck77icubn0003939kgmxl9wag" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/28/hello-world/" class="article-date">
  <time datetime="2019-11-28T05:01:17.541Z" itemprop="datePublished">2019-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hi，你好。欢迎来到Storm的博客，这是我的第一篇文章。作为一个技术人，是有点汗颜，已经在这个圈子里混了两三年了才真正去搭建属于自己的博客。其实也不知道，自己此举能够坚持多久，但是喜欢折腾的个性还是逼自己去做了这件事。不管能做的有多好，也不再去有这个遗憾了。</p>
<p>期望还是要有的，就希望自己能从一个喜欢分享的人，慢慢成长为一个会分享的人吧。一切静静地开始，如果你对我来说是个陌生人，看到一些对你有用的东西那就请你祝福我吧，我们一起努力。成长为更好的自己。如果你是Storm的朋友，那就支持一下我吧，我就是一个需要肯定才会走的更远的人啊。</p>
<h2 id="搭建自己的简易博客"><a href="#搭建自己的简易博客" class="headerlink" title="搭建自己的简易博客"></a>搭建自己的简易博客</h2><h3 id="创建一个Github仓库"><a href="#创建一个Github仓库" class="headerlink" title="创建一个Github仓库"></a>创建一个Github仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">仓库名称格式为：&lt;你的GitHub账户名&gt;.github.io</span></pre></td></tr></table></figure>

<p>传送门: <a href="https://github.com" target="_blank" rel="noopener">Github</a></p>
<h3 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装 git</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置你的账号密码 生成ssh密钥 配置到Github</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装 node.js </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 到目标文件夹 安装 hexo	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#初始化	$ hexo init</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装依赖	$ npm install</span></span></pre></td></tr></table></figure>

<p>传送门: <a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">hexo文档</a></p>
<h3 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ hexo s</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#访问 loaclhost:4000 验证部署</span></span></pre></td></tr></table></figure>

<p>传送门: <a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">hexo文档</a></p>
<h3 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#cd 到hexo安装根目录 修改_config.yml文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里可以按照自己的需要更改标题、副标题等基础配置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#在deploy参数项下增加</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: <span class="string">'git'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">repository: <span class="string">'之前创建的仓库地址'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">branch: <span class="string">'master'</span> <span class="comment">##当然是默认设置成master分支啦</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#保存之后 执行以下命令</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里会提示你输入GitHub的账户名和密码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#然后访问https://&lt;你的GitHub账户名&gt;.github.io 查看部署情况</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#会比较慢 耐心等一下（没办法 毕竟免费的嘛）</span></span></pre></td></tr></table></figure>

<p>嗯 不出意外的话，你就能看到自己亲手搭建的博客啦，虽然功能比较简单，但是刚刚开始玩的话还是非常够用了，博客重要的是分享的内容，而不是花里胡哨的框架啦。然后就开始用Markdown愉快的写文字吧。我们下期再见啦。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/28/hello-world/" data-id="ck77icubj0001939k047gahvu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/02/29/%E5%85%B3%E4%BA%8ECAS%E6%80%9D%E6%83%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">关于CAS思想的一些思考</a>
          </li>
        
          <li>
            <a href="/2020/01/17/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于单元测试的一点思考</a>
          </li>
        
          <li>
            <a href="/2020/01/15/mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/">mysql慢查询分析</a>
          </li>
        
          <li>
            <a href="/2020/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/">记一次线上内存溢出</a>
          </li>
        
          <li>
            <a href="/2019/12/24/%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">关于异常处理的一点思考</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Storm<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>